

plotPredictAspect <- function(obsSA,predSA,slopePlot=T,
                              bubbleSize=.002){
  
  # slope/aspect matrices each have two columns, slope, aspect, in degrees
  #    generated by u2slopeAspect
  
  nPerBin <- nrow(obsSA)/20
  
  if(slopePlot){
    .plotObsPred(obsSA[,1],predSA[,1],nPerBin=nPerBin,xlabel='Degrees',
                 ylabel='Predicted',fill='lightblue', 
                 box.col='darkblue',
                POINTS=F,ylimit=c(0,70))
    .plotLabel('Slope',above=T,cex=2)
    abline(0,1,lty=2)
  }
  
    ww <- which(obsSA[,1] > 5)
    maxVal <- 2*max(obsSA[ww,1])
    symbols(obsSA[ww,2],predSA[ww,2],circles=obsSA[ww,1]*bubbleSize,
            inches=F, xlab='Direction',ylab=' ',xaxt='n',
            yaxt='n',fg='darkblue',bg='lightblue')
    axis(1,at=c(-180,-180/2,0,180/2,180),labels=c('S','W','N','E','S') )
    axis(2,at=c(-180,-180/2,0,180/2,180),labels=c('S','W','N','E','S') )
    abline(0,1,lty=2)
    abline(360,1,lty=2)
    abline(-360,1,lty=2)
    
    alab <- expression( paste( plain(slopes) > 5*degree) )
    
    .plotLabel('Aspect',above=T,cex=1)
    .plotLabel(alab,cex=.9,location='topright')

}

plotAspectEffect <- function( betaSlope,slopeRange=c(.35,.50),
                              aspect=seq(-pi,pi,length=100),minEffect=0,
                              maxNumber=20,
                              ylim=NULL,textSize=1,xlab='Aspect',ylab='Effect'){
  
  # slopeRange - two values giving envelop to plot
  # betaSlope  - 3 u coefficients
  # min2Plot   - plot only those having at least this aspect effect
  
  nn <- length(aspect)
  
  tmp    <- predictSlopeAspect(betaSlope,slopeRange[2],aspect=aspect)
  ub     <- tmp$ubeta
  nu     <- ncol(ub)
  aspect <- tmp$aspect
  maxAsp <- apply(ub,2,which.max) 
  maxEff <- ub[ cbind(maxAsp,1:nu) ]
 # maxAsp <- aspect[ maxAsp ]
  
  tmp    <- predictSlopeAspect(betaSlope,slopeRange[1],aspect=aspect)
  uc     <- tmp$ubeta
  
  mm  <- apply(ub,2,max)
  
  if(minEffect > 0){
    wm  <- which(mm > minEffect)
    mm  <- mm[wm]
    ub  <- ub[,wm]
    uc  <- uc[,wm]
  }
  if(ncol(ub) > maxNumber){
    o <- order(mm,decreasing=T)
    wm <- o[1:maxNumber]
    ub <- ub[,wm]
    uc <- uc[,wm]
  }
  
  bname <- colnames(ub)
  if(is.null(bname))bname <- paste('S',wm,sep='_')
  
  if(is.null(ylim))ylim <- c(0,max(ub)*1.4)
  
  nr <- ncol(ub)
  
  palette(terrain.colors(ncol(ub)+1))
  
  for(s in 1:nr){
    if(s == 1){
      plot(aspect,ub[,s],type='l',ylim=ylim,xaxt='n',xlab=xlab,ylab=ylab)
      axis(1,at=c(-pi,-pi/2,0,pi/2,pi),labels=c('S','W','N','E','S') )
    }
    polygon(c(aspect,rev(aspect)),c(ub[,s],rev(uc[,s])),col=s,border=s)
  }
  for(s in 1:nr){
    lines(aspect,ub[,s],lwd=2,col=s)
    lines(aspect,uc[,s],lwd=2,col=s)
  }
  for(s in 1:nr){
    wx <- which.max(ub[,s])
    text(aspect[wx],ub[wx,s],bname[s],srt=70,pos=4,col='black',cex=textSize)
  }
  invisible( list(maxAspect = maxAsp, maxEffect = maxEff) )
}

u2slopeAspect <- function(umat){
  
  # umat - slope, sin(slope)sin(aspect), sin(slope)cos(aspect)
  
  aspect <- atan2(umat[,2],umat[,3])*180/pi
  slope  <- asin(umat[,1])*180/pi
  cbind(slope, aspect)
}

predictSlopeAspect <- function(betaSlope,slopeValue,
                               aspect=seq(-pi,pi,length=100)){
  
  # betaSlope - matrix of coefficients for u1, u2, u3
  
  nas <- length(aspect)
  S   <- ncol(betaSlope)
  
  ub <- getSlopeAspect(slopeValue,aspect)
  
  ub <- ub%*%betaSlope
  rb <- apply(ub,2,range)
  ub <- ub - matrix(rb[1,],nas,S,byrow=T)
  
  list(ubeta = ub, aspect = aspect)
}


getSlopeAspect <- function(slope,aspect,DEGREES=F){
  #slope   - one value in radians
  #aspect  - vector of values
  #assumes aspect is counterclockwise from North
  
  if(DEGREES){
    slope  <- slope/360 * 2 * pi
    aspect <- aspect/360 * 2 * pi
  }
  
  u1 <- sin(slope)
  u2 <- sin(slope)*sin(aspect)
  u3 <- sin(slope)*cos(aspect)
  
  cbind(u1,u2,u3)
}


